{"id":"s-7ujm","uuid":"1771dedd-68b4-4ec8-98e8-fe8a77df8a9d","title":"Payment Token Service","file_path":"specs/payment_token_service.md","content":"## Overview\nMicroservice responsible for tokenizing payment data from POS hardware. This service handles device-based decryption, re-encryption with rotating keys, token storage, and secure token retrieval. **PCI compliance boundary** - isolated from other services.\n\n## Service Boundaries\n- **Owns**: Payment data encryption/decryption, BDK management, token generation, token-to-payment-data mapping, internal decryption for workers\n- **Does NOT own**: Authorization logic, payment processing, merchant configuration\n- **Isolation**: Separate database, separate deployment, minimal API surface\n\n## Encryption Architecture\n\n### Key Management\n- **BDK (Base Derivation Key)**: Master key stored in AWS KMS, never leaves the service\n- **Device Tokens**: Per-device identifiers provided by POS hardware\n- **Derived Keys**: Generated per-request using KDF(BDK, device_token)\n- **Service Rotating Keys**: Used to re-encrypt tokens, rotated regularly (e.g., every 90 days)\n\n### Encryption Flow\n\n**Token Creation:**\n```\nPOS Device:\n  1. Generates device_token (unique per device)\n  2. Derives encryption key: device_key = KDF(BDK, device_token)\n  3. Encrypts payment data: encrypted = AES-GCM(payment_data, device_key)\n  4. Sends: encrypted_payment_data + device_token\n\nPayment Token Service:\n  1. Retrieves BDK from AWS KMS\n  2. Derives same key: device_key = KDF(BDK, device_token)\n  3. Decrypts: payment_data = decrypt(encrypted_payment_data, device_key)\n  4. Re-encrypts with service key: service_encrypted = AES-GCM(payment_data, rotating_key)\n  5. Stores: payment_token → service_encrypted\n  6. Returns: payment_token\n```\n\n**Token Decryption (Internal):**\n```\nAuth Worker Request:\n  1. Calls POST /internal/decrypt with payment_token\n  \nPayment Token Service:\n  1. Retrieves service_encrypted from database\n  2. Decrypts with current rotating_key: payment_data = decrypt(service_encrypted, rotating_key)\n  3. Returns: payment_data (in memory only, never persisted)\n```\n\n## API Specification\n\n### POST /payment-tokens\nCreates a payment token from device-encrypted payment data.\n\n**Request:**\n```protobuf\nmessage CreatePaymentTokenRequest {\n  string restaurant_id = 1;  // UUID of the restaurant/merchant\n  bytes encrypted_payment_data = 2;  // Encrypted by POS device with derived key\n  string device_token = 3;  // Device identifier for key derivation\n  string idempotency_key = 4;  // Client-provided idempotency key\n  map<string, string> metadata = 5;  // Optional metadata (card brand, last4, etc.)\n}\n\nmessage CreatePaymentTokenResponse {\n  string payment_token = 1;  // Generated token (UUID format: pt_...)\n  string restaurant_id = 2;\n  int64 expires_at = 3;  // Unix timestamp\n  map<string, string> metadata = 4;  // Echoed metadata\n}\n```\n\n**HTTP:**\n```\nPOST /v1/payment-tokens\nContent-Type: application/x-protobuf\nX-Idempotency-Key: <uuid>\nAuthorization: Bearer <api_key>\n\nResponse:\n201 Created - Token created successfully\n200 OK - Idempotent request, returning existing token\n400 Bad Request - Invalid request or decryption failed\n401 Unauthorized - Invalid API key\n500 Internal Server Error\n```\n\n### GET /payment-tokens/{token_id}\nRetrieves payment token metadata (NOT the actual payment data).\n\n**Request:**\n```protobuf\nmessage GetPaymentTokenRequest {\n  string payment_token = 1;\n  string restaurant_id = 2;  // Must match token owner\n}\n\nmessage GetPaymentTokenResponse {\n  string payment_token = 1;\n  string restaurant_id = 2;\n  int64 created_at = 3;\n  int64 expires_at = 4;\n  bool is_expired = 5;\n  map<string, string> metadata = 6;\n}\n```\n\n**HTTP:**\n```\nGET /v1/payment-tokens/{token_id}?restaurant_id={restaurant_id}\nAuthorization: Bearer <api_key>\n\nResponse:\n200 OK - Token found\n404 Not Found - Token doesn't exist or doesn't belong to restaurant\n410 Gone - Token expired\n```\n\n### POST /internal/decrypt (Internal Only)\nDecrypts a payment token and returns raw payment data. **Only accessible by Auth Processor Workers and Void Workers** within VPC.\n\n**Request:**\n```protobuf\nmessage DecryptPaymentTokenRequest {\n  string payment_token = 1;\n  string restaurant_id = 2;  // For authorization check\n  string requesting_service = 3;  // \"auth-processor-worker\", \"void-processor-worker\"\n}\n\nmessage DecryptPaymentTokenResponse {\n  PaymentData payment_data = 1;\n  map<string, string> metadata = 2;  // card_brand, last4, etc.\n}\n\nmessage PaymentData {\n  string card_number = 1;  // Full PAN\n  string exp_month = 2;  // MM\n  string exp_year = 3;  // YYYY\n  string cvv = 4;\n  string cardholder_name = 5;\n  \n  // Billing address (if available)\n  Address billing_address = 6;\n}\n\nmessage Address {\n  string line1 = 1;\n  string line2 = 2;\n  string city = 3;\n  string state = 4;\n  string postal_code = 5;\n  string country = 6;  // ISO 3166-1 alpha-2\n}\n```\n\n**HTTP:**\n```\nPOST /internal/v1/decrypt\nContent-Type: application/x-protobuf\nX-Service-Auth: <internal-service-token>\nX-Request-ID: <correlation-id>\n\nResponse:\n200 OK - Token decrypted successfully\n400 Bad Request - Invalid token format\n404 Not Found - Token not found\n410 Gone - Token expired\n403 Forbidden - Restaurant ID mismatch or unauthorized service\n500 Internal Server Error\n```\n\n## Behaviors\n\n### B1: Token Creation with Idempotency\n**Given** a client calls POST /payment-tokens with an idempotency key\n**When** the same idempotency key is used within 24 hours\n**Then** the same token is returned (idempotent behavior)\n**And** no duplicate database entries are created\n\n### B2: Device-Based Decryption\n**Given** POS device encrypts payment data with derived key\n**When** Payment Token Service receives encrypted data + device_token\n**Then** derive decryption key using BDK and device_token\n**And** decrypt payment data\n**And** fail with 400 if decryption fails (invalid device_token or corrupted data)\n\n### B3: Re-encryption with Rotating Keys\n**Given** decrypted payment data\n**When** storing in database\n**Then** re-encrypt using current service rotating key\n**And** store key version for future decryption\n**And** support multiple key versions during rotation period\n\n### B4: Token Expiration\n**Given** a payment token is created\n**When** 24 hours have passed (configurable per restaurant)\n**Then** the token is marked as expired and cannot be used for new authorizations\n**And** GET requests return 410 Gone\n**And** Decrypt requests return 410 Gone\n\n### B5: Restaurant Scoping\n**Given** a payment token\n**When** any operation is performed\n**Then** the token can only be accessed by the restaurant that created it\n**And** attempts to access with wrong restaurant_id return 403 Forbidden\n\n### B6: Internal Decryption Authorization\n**Given** a decrypt request to /internal/decrypt\n**When** requesting_service is not in allowlist [\"auth-processor-worker\", \"void-processor-worker\"]\n**Then** return 403 Forbidden\n**And** log security violation\n\n### B7: Audit Logging for Decryption\n**Given** any decrypt request (internal API)\n**When** processed (success or failure)\n**Then** log: payment_token, restaurant_id, requesting_service, timestamp, result\n**And** logs are immutable and retained for 7 years (PCI compliance)\n\n### B8: Key Rotation Support\n**Given** service rotating keys are rotated (e.g., every 90 days)\n**When** old tokens are decrypted\n**Then** use key_version stored with token to select correct decryption key\n**And** support N previous key versions (e.g., 4 versions = 1 year retention)\n**And** background job re-encrypts old tokens with new key\n\n### B9: BDK Security\n**Given** BDK must never leave AWS KMS\n**When** deriving device keys\n**Then** use KMS Decrypt API with encryption context\n**And** derived keys exist only in memory, never persisted\n**And** rotate BDK annually with migration process\n\n## Database Schema\n\n```sql\nCREATE TABLE payment_tokens (\n    payment_token VARCHAR(64) PRIMARY KEY,  -- pt_<uuid>\n    restaurant_id UUID NOT NULL,\n    \n    -- Re-encrypted payment data (service key)\n    encrypted_payment_data BYTEA NOT NULL,\n    encryption_key_version VARCHAR(50) NOT NULL,  -- For key rotation\n    \n    -- Original device info (for audit)\n    device_token VARCHAR(255) NOT NULL,\n    \n    -- Lifecycle\n    created_at TIMESTAMP NOT NULL DEFAULT NOW(),\n    expires_at TIMESTAMP NOT NULL,\n    \n    -- Metadata (non-sensitive)\n    metadata JSONB,  -- card_brand, last4, exp_month (for display)\n    \n    INDEX idx_restaurant_created (restaurant_id, created_at),\n    INDEX idx_expires_at (expires_at) WHERE expires_at > NOW()\n);\n\nCREATE TABLE token_idempotency_keys (\n    idempotency_key VARCHAR(255) NOT NULL,\n    restaurant_id UUID NOT NULL,\n    payment_token VARCHAR(64) NOT NULL REFERENCES payment_tokens(payment_token),\n    created_at TIMESTAMP NOT NULL DEFAULT NOW(),\n    expires_at TIMESTAMP NOT NULL DEFAULT NOW() + INTERVAL '24 hours',\n    \n    PRIMARY KEY (idempotency_key, restaurant_id),\n    INDEX idx_expires_at (expires_at)\n);\n\n-- Encryption key versions (for rotation)\nCREATE TABLE encryption_keys (\n    key_version VARCHAR(50) PRIMARY KEY,\n    kms_key_id VARCHAR(255) NOT NULL,  -- AWS KMS key ARN\n    created_at TIMESTAMP NOT NULL DEFAULT NOW(),\n    is_active BOOLEAN NOT NULL DEFAULT true,\n    retired_at TIMESTAMP,\n    \n    CONSTRAINT only_one_active CHECK (\n        NOT is_active OR \n        (SELECT COUNT(*) FROM encryption_keys WHERE is_active = true) = 1\n    )\n);\n\n-- Audit log for decryption requests (PCI compliance)\nCREATE TABLE decrypt_audit_log (\n    id BIGSERIAL PRIMARY KEY,\n    payment_token VARCHAR(64) NOT NULL,\n    restaurant_id UUID NOT NULL,\n    requesting_service VARCHAR(100) NOT NULL,\n    request_id VARCHAR(255) NOT NULL,  -- Correlation ID\n    success BOOLEAN NOT NULL,\n    error_code VARCHAR(50),\n    created_at TIMESTAMP NOT NULL DEFAULT NOW(),\n    \n    INDEX idx_token_created (payment_token, created_at),\n    INDEX idx_created_at (created_at)\n);\n\n-- Partition audit log by month for archival\nCREATE TABLE decrypt_audit_log_2024_01 PARTITION OF decrypt_audit_log\n    FOR VALUES FROM ('2024-01-01') TO ('2024-02-01');\n```\n\n## Key Derivation Function (KDF)\n\nUse **HKDF (HMAC-based Key Derivation Function)** per RFC 5869:\n\n```python\ndef derive_device_key(bdk: bytes, device_token: str) -> bytes:\n    \"\"\"\n    Derives device-specific encryption key from BDK.\n    \n    Args:\n        bdk: Base Derivation Key (from AWS KMS)\n        device_token: Device identifier\n    \n    Returns:\n        32-byte AES-256 key\n    \"\"\"\n    return HKDF(\n        algorithm=hashes.SHA256(),\n        length=32,\n        salt=None,\n        info=b\"payment-token-v1:\" + device_token.encode('utf-8')\n    ).derive(bdk)\n```\n\n## Dependencies\n- **AWS KMS**: For BDK storage and key management\n- **PostgreSQL**: For token storage (isolated instance)\n- None on other microservices (fully isolated)\n\n## Security Requirements\n- **PCI DSS Level 1** compliance\n- **Separate VPC**/network isolation from other services\n- **Separate database instance** (not shared)\n- **Mutual TLS** for internal /decrypt endpoint\n- **API keys** for public endpoints\n- **BDK** never leaves AWS KMS (use KMS Decrypt API)\n- **Derived keys** exist only in memory during request\n- **Audit logging** for all decrypt operations (immutable, 7-year retention)\n- **Encrypted connections only** (TLS 1.3)\n- **Rate limiting** per restaurant and per service\n\n## Configuration\n\n```yaml\nencryption:\n  bdk_kms_key_id: \"arn:aws:kms:us-east-1:...:key/...\"\n  current_key_version: \"v3\"\n  supported_key_versions: [\"v1\", \"v2\", \"v3\"]\n  key_rotation_days: 90\n\ntokens:\n  default_ttl_hours: 24\n  format: \"pt_{uuid}\"\n\ninternal_api:\n  allowed_services:\n    - \"auth-processor-worker\"\n    - \"void-processor-worker\"\n  require_mtls: true\n\nrate_limiting:\n  per_restaurant_rpm: 1000\n  per_service_rpm: 10000\n```\n\n## Deployment\n- **ECS Service** (long-running, not Lambda due to KMS cold start latency)\n- **Auto-scaling** based on CPU and request rate\n- **Health check**: GET /health\n- **Separate VPC subnet** (PCI zone)\n- **Security groups**: Only allow ingress from API Gateway (public) and Auth Workers (internal)\n\n## Key Rotation Process\n\n### Rotating Service Keys (Every 90 Days)\n1. Generate new key version in AWS KMS\n2. Insert new row in `encryption_keys` table with `is_active = true`\n3. Update old key: `is_active = false, retired_at = NOW()`\n4. New tokens use new key immediately\n5. Background job re-encrypts old tokens over 30 days:\n   ```sql\n   UPDATE payment_tokens\n   SET encrypted_payment_data = re_encrypt(encrypted_payment_data, old_key, new_key),\n       encryption_key_version = 'v4'\n   WHERE encryption_key_version = 'v3'\n   LIMIT 1000;\n   ```\n6. After all tokens re-encrypted, delete old KMS key (90 days later)\n\n### Rotating BDK (Annually)\n1. Generate new BDK in AWS KMS\n2. Update configuration to support both old and new BDK\n3. New tokens use new BDK for device key derivation\n4. Keep old BDK for 24 hours (token TTL)\n5. After 24 hours, retire old BDK\n\n## Testing Strategy\n- **Unit tests**: Key derivation, encryption/decryption, idempotency, expiration\n- **Integration tests**: Full API flow with test database + LocalStack KMS\n- **Security tests**: \n  - Cross-restaurant access attempts\n  - Expired token handling\n  - Invalid device_token (decryption failures)\n  - Unauthorized service access to /internal/decrypt\n- **Key rotation tests**: Decrypt tokens encrypted with old key versions\n- **Load tests**: Token creation throughput (target: 500 RPS)\n- **PCI compliance audit**: Annual third-party assessment\n\n## Monitoring & Alerts\n- **Metrics**: Token creation rate, decrypt request rate, KMS API latency, error rates\n- **Alarms**:\n  - Decryption failure rate > 1%\n  - KMS throttling errors\n  - Unauthorized decrypt attempts > 10/min\n- **Audit**: Daily review of decrypt_audit_log for anomalies\n","priority":0,"archived":0,"archived_at":null,"created_at":"2025-11-10 04:35:29","updated_at":"2025-11-10 06:06:22","parent_id":null,"parent_uuid":null,"relationships":[],"tags":["pci-compliant","service-spec","tokenization"]}
{"id":"s-9jeq","uuid":"152dae2a-283e-476c-926b-785cc96de8a4","title":"Authorization API Service","file_path":"specs/authorization_api_service.md","content":"## Overview\nPrimary API service for handling payment authorization requests. Implements event sourcing with **Transactional Outbox Pattern**, idempotency, and request/response polling. This is the main entry point for restaurant POS systems.\n\n## Service Boundaries\n- **Owns**: Auth request lifecycle, event storage, read model updates, idempotency, status queries, void requests, outbox processing\n- **Does NOT own**: Actual payment processing (delegated to workers), token decryption, processor integration\n- **Responsibilities**: API layer, event sourcing, read model maintenance (synchronous), queue management via outbox\n\n## Transaction Boundaries & Outbox Pattern\n\n### Critical Design Decision: At-Least-Once Delivery via Outbox\n\nTo ensure **atomic** event writes + queue messages, we use the **Transactional Outbox Pattern**:\n\n```\n┌─────────────────────────────────────────────────────────┐\n│                  POST /authorize                         │\n│                                                          │\n│  BEGIN TRANSACTION                                       │\n│    1. Check idempotency                                  │\n│    2. Write event: AuthRequestCreated                    │\n│    3. Update read model: auth_request_state (INSERT)     │\n│    4. Write to outbox: auth_request_queued               │\n│  COMMIT (all or nothing!)                                │\n│                                                          │\n│  Return auth_request_id to client                        │\n└─────────────────────────────────────────────────────────┘\n                          │\n                          │ (asynchronously)\n                          ▼\n┌─────────────────────────────────────────────────────────┐\n│              Outbox Processor (background)               │\n│                                                          │\n│  Every 100ms:                                            │\n│    1. SELECT * FROM outbox WHERE processed_at IS NULL    │\n│       FOR UPDATE SKIP LOCKED LIMIT 100                   │\n│    2. Send each message to SQS                           │\n│    3. UPDATE outbox SET processed_at = NOW()             │\n└─────────────────────────────────────────────────────────┘\n```\n\n**Guarantees:**\n- ✅ Event + Read Model + Outbox written atomically\n- ✅ At-least-once delivery to SQS (outbox processor retries until success)\n- ✅ No message loss (even if outbox processor crashes, messages remain in DB)\n- ✅ SQS FIFO deduplication handles any duplicate sends\n\n## API Specification\n\n### POST /authorize\nCreates an authorization request and waits up to 5 seconds for completion.\n\n**Request:**\n```protobuf\nmessage AuthorizeRequest {\n  string payment_token = 1;  // From Payment Token Service\n  string restaurant_id = 2;  // UUID of restaurant\n  int64 amount_cents = 3;  // Amount in cents (e.g., 1050 = $10.50)\n  string currency = 4;  // ISO 4217 currency code (e.g., \"USD\")\n  string idempotency_key = 5;  // Client-provided\n  map<string, string> metadata = 6;  // Optional: order_id, table_number, etc.\n}\n\nmessage AuthorizeResponse {\n  string auth_request_id = 1;  // UUID\n  AuthStatus status = 2;\n  \n  // Populated if status = AUTHORIZED or DENIED\n  AuthorizationResult result = 3;\n  \n  // Populated if status = PROCESSING\n  string status_url = 4;  // URL to poll for status\n}\n\nenum AuthStatus {\n  PROCESSING = 0;  // Still in progress\n  AUTHORIZED = 1;  // Successfully authorized\n  DENIED = 2;  // Declined by processor\n  FAILED = 3;  // System error\n  VOIDED = 4;  // Voided by user\n  EXPIRED = 5;  // Request expired before processing\n}\n\nmessage AuthorizationResult {\n  string processor_auth_id = 1;  // e.g., Stripe charge ID\n  string processor_name = 2;  // \"stripe\", \"chase\", etc.\n  int64 authorized_amount_cents = 3;\n  string currency = 4;\n  string authorization_code = 5;  // Processor-provided auth code\n  int64 authorized_at = 6;  // Unix timestamp\n  \n  // For DENIED status\n  string denial_code = 7;  // Processor decline code\n  string denial_reason = 8;  // Human-readable reason\n  \n  map<string, string> processor_metadata = 9;  // Raw processor response\n}\n```\n\n**HTTP:**\n```\nPOST /v1/authorize\nContent-Type: application/x-protobuf\nX-Idempotency-Key: <uuid>\n\nResponse:\n200 OK - Authorization completed within 5 seconds (AUTHORIZED/DENIED)\n202 Accepted - Authorization still processing (client should poll)\n400 Bad Request - Invalid request\n404 Not Found - Payment token not found/expired\n409 Conflict - Auth request already voided\n500 Internal Server Error\n```\n\n**Implementation (Pseudocode):**\n```python\nasync def post_authorize(request: AuthorizeRequest) -> AuthorizeResponse:\n    # 1. Check idempotency\n    existing = await db.fetch_one(\n        \"SELECT auth_request_id FROM auth_idempotency_keys WHERE idempotency_key = $1\",\n        request.idempotency_key\n    )\n    if existing:\n        return await get_status(existing.auth_request_id)\n    \n    auth_request_id = generate_uuid()\n    \n    # 2. ATOMIC TRANSACTION\n    async with db.transaction():\n        # 2a. Write event\n        await db.execute(\"\"\"\n            INSERT INTO payment_events (event_id, aggregate_id, aggregate_type, event_type, event_data, sequence_number)\n            VALUES ($1, $2, 'auth_request', 'AuthRequestCreated', $3, 1)\n        \"\"\", generate_uuid(), auth_request_id, serialize_protobuf(AuthRequestCreated(...)))\n        \n        # 2b. Write read model (strong consistency!)\n        await db.execute(\"\"\"\n            INSERT INTO auth_request_state (auth_request_id, restaurant_id, payment_token, status, amount_cents, currency, created_at, updated_at, last_event_sequence)\n            VALUES ($1, $2, $3, 'PENDING', $4, $5, NOW(), NOW(), 1)\n        \"\"\", auth_request_id, request.restaurant_id, request.payment_token, request.amount_cents, request.currency)\n        \n        # 2c. Write to outbox (reliable queue delivery!)\n        await db.execute(\"\"\"\n            INSERT INTO outbox (aggregate_id, message_type, payload, created_at)\n            VALUES ($1, 'auth_request_queued', $2, NOW())\n        \"\"\", auth_request_id, json.dumps({\n            \"auth_request_id\": auth_request_id,\n            \"restaurant_id\": request.restaurant_id\n        }))\n        \n        # 2d. Write idempotency key\n        await db.execute(\"\"\"\n            INSERT INTO auth_idempotency_keys (idempotency_key, auth_request_id, restaurant_id, created_at, expires_at)\n            VALUES ($1, $2, $3, NOW(), NOW() + INTERVAL '24 hours')\n        \"\"\", request.idempotency_key, auth_request_id, request.restaurant_id)\n        \n        # COMMIT - all or nothing!\n    \n    # 3. Wait up to 5 seconds for response (poll read model)\n    for _ in range(50):  # 50 * 100ms = 5 seconds\n        await asyncio.sleep(0.1)\n        \n        state = await db.fetch_one(\n            \"SELECT status, processor_auth_id, authorization_code, denial_code, denial_reason FROM auth_request_state WHERE auth_request_id = $1\",\n            auth_request_id\n        )\n        \n        if state.status in ('AUTHORIZED', 'DENIED', 'FAILED'):\n            return AuthorizeResponse(\n                auth_request_id=auth_request_id,\n                status=state.status,\n                result=AuthorizationResult(...) if state.status != 'FAILED' else None\n            )\n    \n    # 4. Timeout - return 202 Accepted\n    return AuthorizeResponse(\n        auth_request_id=auth_request_id,\n        status=AuthStatus.PROCESSING,\n        status_url=f\"/v1/authorize/{auth_request_id}/status\"\n    )\n```\n\n### GET /authorize/{auth_request_id}/status\nPolls for authorization status (reads from read model).\n\n**Request:**\n```protobuf\nmessage GetAuthStatusRequest {\n  string auth_request_id = 1;\n  string restaurant_id = 2;  // Must match\n}\n\nmessage GetAuthStatusResponse {\n  string auth_request_id = 1;\n  AuthStatus status = 2;\n  AuthorizationResult result = 3;  // If completed\n  int64 created_at = 4;\n  int64 updated_at = 5;\n}\n```\n\n**HTTP:**\n```\nGET /v1/authorize/{auth_request_id}/status?restaurant_id={restaurant_id}\n\nResponse:\n200 OK - Status retrieved\n404 Not Found - Auth request not found or wrong restaurant\n```\n\n**Implementation:**\n```python\nasync def get_status(auth_request_id: str, restaurant_id: str) -> GetAuthStatusResponse:\n    # Simple read from read model (no transaction needed)\n    state = await db.fetch_one(\"\"\"\n        SELECT auth_request_id, status, processor_auth_id, processor_name, \n               authorized_amount_cents, authorization_code, denial_code, denial_reason,\n               created_at, updated_at\n        FROM auth_request_state\n        WHERE auth_request_id = $1 AND restaurant_id = $2\n    \"\"\", auth_request_id, restaurant_id)\n    \n    if not state:\n        raise NotFound(\"Auth request not found\")\n    \n    return GetAuthStatusResponse(\n        auth_request_id=state.auth_request_id,\n        status=state.status,\n        result=build_result(state) if state.status in ('AUTHORIZED', 'DENIED') else None,\n        created_at=state.created_at,\n        updated_at=state.updated_at\n    )\n```\n\n### POST /authorize/{auth_request_id}/void\nVoids an authorization request (similar transaction pattern).\n\n**Request:**\n```protobuf\nmessage VoidAuthRequest {\n  string auth_request_id = 1;\n  string restaurant_id = 2;\n  string reason = 3;  // Optional: \"customer_cancelled\", etc.\n  string idempotency_key = 4;\n}\n\nmessage VoidAuthResponse {\n  string auth_request_id = 1;\n  VoidStatus status = 2;\n  int64 voided_at = 3;\n}\n\nenum VoidStatus {\n  VOID_PENDING = 0;  // Void request queued\n  VOID_COMPLETED = 1;  // Void successful\n  VOID_FAILED = 2;  // Could not void (already captured, etc.)\n  VOID_NOT_REQUIRED = 3;  // Never authorized, just cancelled queue\n}\n```\n\n**HTTP:**\n```\nPOST /v1/authorize/{auth_request_id}/void\nContent-Type: application/x-protobuf\n\nResponse:\n200 OK - Void processed\n404 Not Found - Auth request not found\n409 Conflict - Already voided or captured\n```\n\n**Implementation:**\n```python\nasync def post_void(auth_request_id: str, request: VoidAuthRequest) -> VoidAuthResponse:\n    async with db.transaction():\n        # 1. Get current state\n        state = await db.fetch_one(\n            \"SELECT status FROM auth_request_state WHERE auth_request_id = $1 AND restaurant_id = $2 FOR UPDATE\",\n            auth_request_id, request.restaurant_id\n        )\n        \n        if not state:\n            raise NotFound(\"Auth request not found\")\n        \n        if state.status == 'VOIDED':\n            raise Conflict(\"Already voided\")\n        \n        # 2. Write void event\n        next_seq = await db.fetch_val(\n            \"SELECT MAX(sequence_number) + 1 FROM payment_events WHERE aggregate_id = $1\",\n            auth_request_id\n        )\n        \n        await db.execute(\"\"\"\n            INSERT INTO payment_events (event_id, aggregate_id, aggregate_type, event_type, event_data, sequence_number)\n            VALUES ($1, $2, 'auth_request', 'AuthVoidRequested', $3, $4)\n        \"\"\", generate_uuid(), auth_request_id, serialize_protobuf(AuthVoidRequested(...)), next_seq)\n        \n        # 3. Update read model\n        await db.execute(\"\"\"\n            UPDATE auth_request_state\n            SET status = 'VOIDED', updated_at = NOW(), last_event_sequence = $2\n            WHERE auth_request_id = $1\n        \"\"\", auth_request_id, next_seq)\n        \n        # 4. If AUTHORIZED, write to outbox for void worker\n        if state.status == 'AUTHORIZED':\n            await db.execute(\"\"\"\n                INSERT INTO outbox (aggregate_id, message_type, payload, created_at)\n                VALUES ($1, 'void_request_queued', $2, NOW())\n            \"\"\", auth_request_id, json.dumps({\n                \"auth_request_id\": auth_request_id,\n                \"restaurant_id\": request.restaurant_id,\n                \"reason\": request.reason\n            }))\n        \n        # COMMIT\n    \n    return VoidAuthResponse(\n        auth_request_id=auth_request_id,\n        status=VoidStatus.VOID_PENDING if state.status == 'AUTHORIZED' else VoidStatus.VOID_NOT_REQUIRED,\n        voided_at=int(time.time())\n    )\n```\n\n## Outbox Processor (Background Service)\n\n**Runs as separate process/thread within Authorization API deployment.**\n\n```python\nasync def outbox_processor():\n    \"\"\"\n    Background process that polls outbox and sends messages to SQS.\n    Runs continuously every 100ms.\n    \"\"\"\n    while True:\n        try:\n            # 1. Fetch unprocessed messages (with locking to prevent duplicate processing)\n            messages = await db.fetch(\"\"\"\n                SELECT id, aggregate_id, message_type, payload\n                FROM outbox\n                WHERE processed_at IS NULL\n                ORDER BY created_at\n                LIMIT 100\n                FOR UPDATE SKIP LOCKED\n            \"\"\")\n            \n            for msg in messages:\n                try:\n                    # 2. Send to appropriate SQS queue\n                    if msg.message_type == 'auth_request_queued':\n                        await sqs.send_message(\n                            QueueUrl=AUTH_REQUESTS_QUEUE_URL,\n                            MessageBody=msg.payload,\n                            MessageDeduplicationId=msg.aggregate_id,  # SQS FIFO deduplication\n                            MessageGroupId=json.loads(msg.payload)[\"restaurant_id\"]\n                        )\n                    elif msg.message_type == 'void_request_queued':\n                        await sqs.send_message(\n                            QueueUrl=VOID_REQUESTS_QUEUE_URL,\n                            MessageBody=msg.payload\n                        )\n                    \n                    # 3. Mark as processed\n                    await db.execute(\n                        \"UPDATE outbox SET processed_at = NOW() WHERE id = $1\",\n                        msg.id\n                    )\n                    \n                except Exception as e:\n                    # Log error but continue (will retry on next poll)\n                    logger.error(f\"Failed to process outbox message {msg.id}: {e}\")\n            \n            # 4. Sleep 100ms\n            await asyncio.sleep(0.1)\n            \n        except Exception as e:\n            logger.error(f\"Outbox processor error: {e}\")\n            await asyncio.sleep(1)  # Back off on error\n```\n\n## Event Definitions\n\nAll events stored in `payment_events` table.\n\n```protobuf\n// Event: AuthRequestCreated\nmessage AuthRequestCreated {\n  string auth_request_id = 1;\n  string payment_token = 2;\n  string restaurant_id = 3;\n  int64 amount_cents = 4;\n  string currency = 5;\n  map<string, string> metadata = 6;\n  int64 created_at = 7;\n}\n\n// Event: AuthRequestQueued (outbox message type, not an event)\n// Stored as JSON in outbox.payload\n\n// Event: AuthAttemptStarted (written by worker)\nmessage AuthAttemptStarted {\n  string auth_request_id = 1;\n  string worker_id = 2;  // Which worker is processing\n  string restaurant_payment_config_version = 3;\n  int64 started_at = 4;\n}\n\n// Event: AuthResponseReceived (written by worker)\nmessage AuthResponseReceived {\n  string auth_request_id = 1;\n  AuthStatus status = 2;  // AUTHORIZED or DENIED\n  AuthorizationResult result = 3;\n  int64 received_at = 4;\n}\n\n// Event: AuthAttemptFailed (written by worker)\nmessage AuthAttemptFailed {\n  string auth_request_id = 1;\n  string error_code = 2;  // \"token_invalid\", \"processor_timeout\", etc.\n  string error_message = 3;\n  bool is_retryable = 4;\n  int32 retry_count = 5;\n  int64 next_retry_at = 6;  // If retryable\n  int64 failed_at = 7;\n}\n\n// Event: AuthVoidRequested\nmessage AuthVoidRequested {\n  string auth_request_id = 1;\n  string reason = 2;\n  int64 requested_at = 3;\n}\n\n// Event: AuthRequestExpired (written by worker or timeout process)\nmessage AuthRequestExpired {\n  string auth_request_id = 1;\n  int64 expired_at = 2;\n  string reason = 3;  // \"timeout\", \"max_retries_exceeded\", \"voided_before_processing\"\n}\n```\n\n## Behaviors\n\n### B1: Idempotency\n**Given** POST /authorize with idempotency key \"xyz\"\n**When** called multiple times\n**Then** same auth_request_id is returned\n**And** only ONE event is created\n**And** only ONE outbox entry is created\n**And** only ONE SQS message is sent\n\n### B2: Synchronous Response (Fast Path)\n**Given** POST /authorize is called\n**When** processor responds within 5 seconds\n**Then** return 200 with AUTHORIZED or DENIED status\n**And** do NOT return status_url\n\n### B3: Asynchronous Response (Slow Path)\n**Given** POST /authorize is called\n**When** 5 seconds pass without response\n**Then** return 202 Accepted with status_url\n**And** client should poll GET /authorize/{id}/status\n\n### B4: Atomic Event + Read Model + Outbox\n**Given** POST /authorize is called\n**When** transaction commits\n**Then** event, read model, and outbox entry are ALL written atomically\n**When** transaction fails/rolls back\n**Then** NONE are written (no partial state)\n\n### B5: Outbox Guarantees At-Least-Once Delivery\n**Given** outbox entry is written\n**When** outbox processor runs\n**Then** message is sent to SQS at least once\n**And** SQS FIFO deduplication prevents duplicate processing\n**And** even if processor crashes, message remains in outbox and is retried\n\n### B6: Read Model is Strongly Consistent\n**Given** transaction commits with read model update\n**When** GET /authorize/{id}/status is called immediately\n**Then** latest status is returned (no eventual consistency delay)\n\n### B7: Void Before Processing\n**Given** auth request is PENDING or PROCESSING\n**When** void is requested\n**Then** emit AuthVoidRequested event\n**And** update read model status to VOIDED\n**And** worker checks for void event before calling processor\n**And** return VOID_NOT_REQUIRED (no processor call needed)\n\n### B8: Void After Authorization\n**Given** auth request is AUTHORIZED\n**When** void is requested\n**Then** emit AuthVoidRequested event\n**And** update read model status to VOIDED\n**And** enqueue void request to void queue via outbox\n**And** void worker processes void with retries\n\n### B9: Dead Letter - Invalid Token (handled by worker)\n**Given** auth request with invalid/expired token\n**When** worker attempts to process\n**Then** worker writes AuthAttemptFailed event\n**And** worker updates read model status to FAILED\n**And** move to dead letter queue\n\n### B10: Restaurant Payment Config Changes\n**Given** restaurant config changes (e.g., switch from Stripe to Chase)\n**When** queued auth request is processed\n**Then** worker uses CURRENT config at processing time (optimistic read)\n**And** allows replaying with new config\n\n## Database Schema\n\n```sql\n-- Event store (append-only)\nCREATE TABLE payment_events (\n    id BIGSERIAL PRIMARY KEY,\n    event_id UUID UNIQUE NOT NULL,\n    aggregate_id UUID NOT NULL,  -- auth_request_id\n    aggregate_type VARCHAR(50) NOT NULL DEFAULT 'auth_request',\n    event_type VARCHAR(100) NOT NULL,  -- 'AuthRequestCreated', etc.\n    event_data BYTEA NOT NULL,  -- Serialized protobuf\n    metadata JSONB,  -- correlation_id, causation_id, user_id\n    created_at TIMESTAMP NOT NULL DEFAULT NOW(),\n    sequence_number INTEGER NOT NULL,\n    UNIQUE(aggregate_id, sequence_number)\n);\n\nCREATE INDEX idx_aggregate_events ON payment_events(aggregate_id, sequence_number);\nCREATE INDEX idx_event_type_created ON payment_events(event_type, created_at);\nCREATE INDEX idx_created_at ON payment_events(created_at);\n\n-- Read model for fast queries (updated synchronously in same transaction as event)\nCREATE TABLE auth_request_state (\n    auth_request_id UUID PRIMARY KEY,\n    restaurant_id UUID NOT NULL,\n    payment_token VARCHAR(64) NOT NULL,\n    status VARCHAR(20) NOT NULL,  -- PENDING, PROCESSING, AUTHORIZED, etc.\n    amount_cents BIGINT NOT NULL,\n    currency VARCHAR(3) NOT NULL,\n    \n    -- Result (populated when completed by worker)\n    processor_auth_id VARCHAR(255),\n    processor_name VARCHAR(50),\n    authorized_amount_cents BIGINT,\n    authorization_code VARCHAR(100),\n    denial_code VARCHAR(50),\n    denial_reason TEXT,\n    \n    created_at TIMESTAMP NOT NULL,\n    updated_at TIMESTAMP NOT NULL,\n    completed_at TIMESTAMP,\n    \n    metadata JSONB,\n    last_event_sequence INTEGER NOT NULL,  -- For consistency check\n    \n    INDEX idx_restaurant_created (restaurant_id, created_at),\n    INDEX idx_status (status),\n    INDEX idx_payment_token (payment_token)\n);\n\n-- Outbox for reliable queue delivery (Transactional Outbox Pattern)\nCREATE TABLE outbox (\n    id BIGSERIAL PRIMARY KEY,\n    aggregate_id UUID NOT NULL,  -- auth_request_id or void_request_id\n    message_type VARCHAR(100) NOT NULL,  -- 'auth_request_queued', 'void_request_queued'\n    payload JSONB NOT NULL,  -- Message body for SQS\n    created_at TIMESTAMP NOT NULL DEFAULT NOW(),\n    processed_at TIMESTAMP,  -- NULL = unprocessed\n    \n    INDEX idx_unprocessed (created_at) WHERE processed_at IS NULL  -- Partial index for efficiency!\n);\n\n-- Idempotency keys\nCREATE TABLE auth_idempotency_keys (\n    idempotency_key VARCHAR(255) PRIMARY KEY,\n    auth_request_id UUID NOT NULL REFERENCES auth_request_state(auth_request_id),\n    restaurant_id UUID NOT NULL,\n    created_at TIMESTAMP NOT NULL DEFAULT NOW(),\n    expires_at TIMESTAMP NOT NULL DEFAULT NOW() + INTERVAL '24 hours',\n    INDEX idx_expires_at (expires_at)\n);\n\n-- Restaurant payment configs (mocked for now, single Stripe config)\nCREATE TABLE restaurant_payment_configs (\n    restaurant_id UUID PRIMARY KEY,\n    config_version VARCHAR(50) NOT NULL,\n    processor_name VARCHAR(50) NOT NULL,  -- \"stripe\"\n    processor_config JSONB NOT NULL,  -- {\"stripe_api_key\": \"sk_test_...\"}\n    updated_at TIMESTAMP NOT NULL,\n    is_active BOOLEAN NOT NULL DEFAULT true\n);\n\n-- Lock table for workers (used by Auth Processor Worker)\nCREATE TABLE auth_processing_locks (\n    auth_request_id UUID PRIMARY KEY,\n    worker_id VARCHAR(255) NOT NULL,\n    locked_at TIMESTAMP NOT NULL DEFAULT NOW(),\n    expires_at TIMESTAMP NOT NULL,\n    INDEX idx_expires_at (expires_at)\n);\n```\n\n## Dependencies\n- **Payment Token Service**: Validates token exists (not directly called by this service)\n- **SQS FIFO Queue**: Receives auth requests from outbox processor\n- **PostgreSQL**: Event store, read models, outbox\n- **Auth Processor Workers**: Processes queued requests (separate service)\n\n## Queue Configuration\n\n**Auth Request Queue** (SQS FIFO):\n- Name: `auth-requests.fifo`\n- Deduplication: Message deduplication ID = auth_request_id\n- Message Group ID: restaurant_id (ordering per restaurant)\n- Visibility timeout: 30 seconds\n- Max receive count: 5 → Dead letter queue\n\n**Void Request Queue** (SQS Standard):\n- Name: `void-requests`\n- Retries with exponential backoff\n\n**Dead Letter Queues**:\n- `auth-requests-dlq.fifo`: Terminal auth failures\n- `void-requests-dlq`: Failed voids\n\n## Background Jobs\n\n### Outbox Processor\n- **Frequency**: Every 100ms\n- **Batch size**: 100 messages\n- **Responsibility**: Poll outbox, send to SQS, mark as processed\n\n### Expired Idempotency Keys Cleanup\n- **Frequency**: Hourly\n- **Query**: `DELETE FROM auth_idempotency_keys WHERE expires_at < NOW()`\n\n### Expired Locks Cleanup (redundant with worker cleanup, but good hygiene)\n- **Frequency**: Every minute\n- **Query**: `DELETE FROM auth_processing_locks WHERE expires_at < NOW()`\n\n## Deployment\n- **ECS Service** or **Lambda**: API handlers\n- **Background thread/process**: Outbox processor (within same deployment)\n- **Auto-scaling**: Based on request rate\n- **Health check**: GET /health (includes outbox processor health)\n\n## Testing Strategy\n- **Unit tests**: \n  - Transaction logic (event + read model + outbox atomic writes)\n  - Idempotency\n  - State reconstruction from events\n- **Integration tests**: \n  - Full API flow with test database\n  - Outbox processor sends to LocalStack SQS\n  - Verify at-least-once delivery\n- **Behavior tests**: Each behavior spec (B1-B10) has dedicated test\n- **End-to-end tests**: POST /authorize → outbox → SQS → worker processes → GET status returns result\n- **Chaos tests**: Kill outbox processor mid-processing, verify messages are retried\n- **Load tests**: 300 QPS sustained, measure p50/p95/p99 latency","priority":0,"archived":0,"archived_at":null,"created_at":"2025-11-10 04:35:30","updated_at":"2025-11-10 06:40:29","parent_id":null,"parent_uuid":null,"relationships":[],"tags":["api","event-sourcing","service-spec"]}
{"id":"s-w5sf","uuid":"6ed0e286-c807-4bb7-902f-c6975f4fb75b","title":"Auth Processor Worker Service","file_path":"specs/auth_processor_worker_service.md","content":"## Overview\nBackground worker service that dequeues authorization requests, calls external services (payment token service for decryption, payment processors), and records results. Implements exactly-once processing with distributed locking and **atomic event + read model updates**.\n\n## Service Boundaries\n- **Owns**: Auth request processing, processor integration, retry logic, locking, **read model updates for worker events**\n- **Does NOT own**: API layer, event storage schema, token encryption/decryption logic\n- **Responsibilities**: Dequeue, lock, process, record result (event + read model), unlock\n\n## Transaction Boundaries\n\n### Critical: Worker Updates Read Model Atomically\n\nWorkers write events AND update the read model in the **same transaction**:\n\n```\n┌─────────────────────────────────────────────────────────┐\n│            Worker Processes Auth Request                 │\n│                                                          │\n│  BEGIN TRANSACTION                                       │\n│    1. Write event: AuthResponseReceived                  │\n│    2. Update read model: auth_request_state              │\n│       SET status = 'AUTHORIZED', processor_auth_id = ... │\n│  COMMIT (all or nothing!)                                │\n│                                                          │\n│  DELETE SQS message                                      │\n└─────────────────────────────────────────────────────────┘\n```\n\n**Guarantees:**\n- ✅ Event + Read Model written atomically\n- ✅ If transaction fails, SQS message remains visible (will retry)\n- ✅ Read model always reflects latest event\n- ✅ No eventual consistency delay\n\n## Worker Architecture\n\n```\n┌─────────────────────────────────────────────────────────┐\n│         SQS FIFO Consumer (Auth Request Queue)          │\n│  - Long polling (20 second wait)                        │\n│  - Batch size: 1 (for simplicity, can optimize later)  │\n│  - Visibility timeout: 30 seconds                       │\n└─────────────────────────────────────────────────────────┘\n                        │\n                        ▼\n┌─────────────────────────────────────────────────────────┐\n│              Acquire Distributed Lock                    │\n│  - INSERT INTO auth_processing_locks                    │\n│  - If lock exists and not expired → skip (race)         │\n│  - Lock TTL: 30 seconds                                 │\n└─────────────────────────────────────────────────────────┘\n                        │\n                        ▼\n┌─────────────────────────────────────────────────────────┐\n│           Check for Void Event (Race Check)             │\n│  - Query: SELECT event_type = 'AuthVoidRequested'      │\n│  - If found → skip processing, delete from queue        │\n└─────────────────────────────────────────────────────────┘\n                        │\n                        ▼\n┌─────────────────────────────────────────────────────────┐\n│      Fetch Restaurant Payment Config (Optimistic)       │\n│  - Read from cached table: restaurant_payment_configs   │\n│  - Determines which processor to use                    │\n└─────────────────────────────────────────────────────────┘\n                        │\n                        ▼\n┌─────────────────────────────────────────────────────────┐\n│    Call Payment Token Service /internal/decrypt         │\n│  - POST /internal/decrypt                               │\n│  - Returns decrypted payment data                       │\n└─────────────────────────────────────────────────────────┘\n                        │\n                        ▼\n┌─────────────────────────────────────────────────────────┐\n│        Call Payment Processor (Stripe, Chase, etc)      │\n│  - Stripe: POST /v1/charges                             │\n│  - Handle response: success, decline, error             │\n└─────────────────────────────────────────────────────────┘\n                        │\n                        ▼\n┌─────────────────────────────────────────────────────────┐\n│     ATOMIC: Write Event + Update Read Model             │\n│  BEGIN TRANSACTION                                       │\n│    - Write event: AuthResponseReceived                   │\n│    - Update auth_request_state                          │\n│  COMMIT                                                  │\n└─────────────────────────────────────────────────────────┘\n                        │\n                        ▼\n┌─────────────────────────────────────────────────────────┐\n│              Release Lock & Delete Message              │\n│  - DELETE FROM auth_processing_locks                    │\n│  - SQS DeleteMessage (ack)                              │\n└─────────────────────────────────────────────────────────┘\n```\n\n## Processing Logic (Pseudocode)\n\n```python\nasync def process_auth_request(message: SQSMessage):\n    auth_request_id = message.body['auth_request_id']\n    \n    # 1. Acquire lock\n    lock_acquired = await acquire_lock(auth_request_id)\n    if not lock_acquired:\n        # Another worker is processing, skip\n        return\n    \n    try:\n        # 2. Check for void (race condition check)\n        if await is_voided(auth_request_id):\n            # Write void completion event + update read model atomically\n            async with db.transaction():\n                await record_event(AuthRequestExpired(\n                    auth_request_id=auth_request_id,\n                    reason=\"voided_before_processing\"\n                ))\n                await db.execute(\"\"\"\n                    UPDATE auth_request_state\n                    SET status = 'EXPIRED', updated_at = NOW()\n                    WHERE auth_request_id = $1\n                \"\"\", auth_request_id)\n            \n            await delete_message(message)\n            return\n        \n        # 3. Emit processing event + update read model atomically\n        async with db.transaction():\n            next_seq = await get_next_sequence(auth_request_id)\n            await record_event(AuthAttemptStarted(\n                auth_request_id=auth_request_id,\n                worker_id=WORKER_ID,\n                started_at=now()\n            ), sequence=next_seq)\n            \n            await db.execute(\"\"\"\n                UPDATE auth_request_state\n                SET status = 'PROCESSING', updated_at = NOW(), last_event_sequence = $2\n                WHERE auth_request_id = $1\n            \"\"\", auth_request_id, next_seq)\n        \n        # 4. Fetch auth request details\n        auth_req = await get_auth_request(auth_request_id)\n        \n        # 5. Fetch restaurant config (optimistic)\n        config = await get_restaurant_config(auth_req.restaurant_id)\n        \n        # 6. Decrypt payment token via Payment Token Service\n        try:\n            payment_data = await payment_token_service.decrypt(\n                payment_token=auth_req.payment_token,\n                restaurant_id=auth_req.restaurant_id,\n                requesting_service=\"auth-processor-worker\"\n            )\n        except TokenNotFound:\n            # Terminal error - write event + update read model + dead letter\n            async with db.transaction():\n                next_seq = await get_next_sequence(auth_request_id)\n                await record_event(AuthAttemptFailed(\n                    auth_request_id=auth_request_id,\n                    error_code=\"token_invalid\",\n                    is_retryable=False\n                ), sequence=next_seq)\n                \n                await db.execute(\"\"\"\n                    UPDATE auth_request_state\n                    SET status = 'FAILED', updated_at = NOW(), last_event_sequence = $2\n                    WHERE auth_request_id = $1\n                \"\"\", auth_request_id, next_seq)\n            \n            await send_to_dlq(message)\n            await delete_message(message)\n            return\n        \n        except TokenExpired:\n            # Terminal error - write event + update read model + dead letter\n            async with db.transaction():\n                next_seq = await get_next_sequence(auth_request_id)\n                await record_event(AuthAttemptFailed(\n                    auth_request_id=auth_request_id,\n                    error_code=\"token_expired\",\n                    is_retryable=False\n                ), sequence=next_seq)\n                \n                await db.execute(\"\"\"\n                    UPDATE auth_request_state\n                    SET status = 'FAILED', updated_at = NOW(), last_event_sequence = $2\n                    WHERE auth_request_id = $1\n                \"\"\", auth_request_id, next_seq)\n            \n            await send_to_dlq(message)\n            await delete_message(message)\n            return\n        \n        # 7. Call processor\n        processor = get_processor_client(config.processor_name)\n        try:\n            result = await processor.authorize(\n                payment_data=payment_data,\n                amount_cents=auth_req.amount_cents,\n                currency=auth_req.currency,\n                config=config.processor_config\n            )\n            \n            # 8. ATOMIC: Record event + update read model\n            async with db.transaction():\n                next_seq = await get_next_sequence(auth_request_id)\n                \n                # Write event\n                await record_event(AuthResponseReceived(\n                    auth_request_id=auth_request_id,\n                    status=result.status,  # AUTHORIZED or DENIED\n                    result=result\n                ), sequence=next_seq)\n                \n                # Update read model\n                if result.status == AuthStatus.AUTHORIZED:\n                    await db.execute(\"\"\"\n                        UPDATE auth_request_state\n                        SET status = 'AUTHORIZED',\n                            processor_auth_id = $2,\n                            processor_name = $3,\n                            authorized_amount_cents = $4,\n                            authorization_code = $5,\n                            completed_at = NOW(),\n                            updated_at = NOW(),\n                            last_event_sequence = $6\n                        WHERE auth_request_id = $1\n                    \"\"\", auth_request_id, result.processor_auth_id, result.processor_name,\n                         result.authorized_amount_cents, result.authorization_code, next_seq)\n                \n                elif result.status == AuthStatus.DENIED:\n                    await db.execute(\"\"\"\n                        UPDATE auth_request_state\n                        SET status = 'DENIED',\n                            processor_name = $2,\n                            denial_code = $3,\n                            denial_reason = $4,\n                            completed_at = NOW(),\n                            updated_at = NOW(),\n                            last_event_sequence = $5\n                        WHERE auth_request_id = $1\n                    \"\"\", auth_request_id, result.processor_name, result.denial_code,\n                         result.denial_reason, next_seq)\n                \n                # COMMIT - event + read model together!\n            \n            # 9. Delete from queue (after successful commit)\n            await delete_message(message)\n            \n        except ProcessorTimeout:\n            # Retryable error - record attempt but don't update status to FAILED yet\n            retry_count = message.attributes['ApproximateReceiveCount']\n            \n            if retry_count >= MAX_RETRIES:\n                # Max retries exceeded - terminal failure\n                async with db.transaction():\n                    next_seq = await get_next_sequence(auth_request_id)\n                    await record_event(AuthAttemptFailed(\n                        auth_request_id=auth_request_id,\n                        error_code=\"processor_timeout\",\n                        is_retryable=False,\n                        retry_count=retry_count\n                    ), sequence=next_seq)\n                    \n                    await db.execute(\"\"\"\n                        UPDATE auth_request_state\n                        SET status = 'FAILED', updated_at = NOW(), last_event_sequence = $2\n                        WHERE auth_request_id = $1\n                    \"\"\", auth_request_id, next_seq)\n                \n                await send_to_dlq(message)\n                await delete_message(message)\n            else:\n                # Let it retry - just record the attempt\n                async with db.transaction():\n                    next_seq = await get_next_sequence(auth_request_id)\n                    await record_event(AuthAttemptFailed(\n                        auth_request_id=auth_request_id,\n                        error_code=\"processor_timeout\",\n                        is_retryable=True,\n                        retry_count=retry_count,\n                        next_retry_at=now() + exponential_backoff(retry_count)\n                    ), sequence=next_seq)\n                    \n                    # Don't update status - keep as PROCESSING\n                    await db.execute(\"\"\"\n                        UPDATE auth_request_state\n                        SET updated_at = NOW(), last_event_sequence = $2\n                        WHERE auth_request_id = $1\n                    \"\"\", auth_request_id, next_seq)\n                \n                # Don't delete - let visibility timeout expire for retry\n    \n    finally:\n        # Always release lock\n        await release_lock(auth_request_id)\n```\n\n## Behaviors\n\n### B1: Exactly-Once Processing\n**Given** an auth request is queued\n**When** multiple workers attempt to process\n**Then** only ONE worker acquires the lock\n**And** only ONE processor call is made\n**And** lock prevents duplicate attempts\n\n### B2: Atomic Event + Read Model Update\n**Given** worker processes auth successfully\n**When** writing result\n**Then** event AND read model are written in same transaction\n**And** both commit or both rollback (no partial state)\n**And** read model immediately reflects latest event\n\n### B3: Void Race Condition Handling\n**Given** void is requested while auth is being processed\n**When** worker checks for void event before calling processor\n**Then** if void event exists, skip processing\n**And** atomically write AuthRequestExpired event + update read model to EXPIRED\n\n### B4: Transient Failure Retry\n**Given** processor returns 500 or timeout\n**When** retry count < MAX_RETRIES (5)\n**Then** record AuthAttemptFailed event with is_retryable=true\n**And** status remains PROCESSING (not FAILED yet)\n**And** message becomes visible again after visibility timeout\n**And** retry with exponential backoff\n\n### B5: Terminal Failure - Invalid Token\n**Given** Payment Token Service returns 404 (token not found)\n**When** worker processes\n**Then** atomically write AuthAttemptFailed event + update read model to FAILED\n**And** send to dead letter queue\n**And** do NOT retry\n\n### B6: Terminal Failure - Expired Token\n**Given** Payment Token Service returns 410 (token expired)\n**When** worker processes\n**Then** atomically write AuthAttemptFailed event + update read model to FAILED\n**And** send to dead letter queue\n**And** do NOT retry\n\n### B7: Terminal Failure - Max Retries\n**Given** processor fails 5 times\n**When** retry count = MAX_RETRIES\n**Then** atomically write final AuthAttemptFailed event + update read model to FAILED\n**And** send to dead letter queue\n\n### B8: Processor Denial (Not a Failure)\n**Given** processor returns decline (e.g., insufficient funds)\n**When** worker processes\n**Then** atomically write AuthResponseReceived (status=DENIED) + update read model to DENIED\n**And** include denial_code and denial_reason in read model\n**And** this is NOT a failure (expected outcome)\n**And** mark as completed\n\n### B9: Lock Timeout (Worker Crash)\n**Given** worker crashes while holding lock\n**When** lock TTL expires (30 seconds)\n**Then** another worker can acquire lock\n**And** reprocess the request\n**And** read model tracks retry count via events\n\n### B10: Config-Based Processor Routing\n**Given** restaurant config specifies processor=\"stripe\"\n**When** worker processes auth request\n**Then** use Stripe client\n**When** config changes to processor=\"chase\"\n**Then** new requests use Chase client\n**And** replayed requests use current config\n\n### B11: Payment Token Service Unavailable\n**Given** Payment Token Service is down or timing out\n**When** worker attempts to decrypt token\n**Then** treat as retryable error (like processor timeout)\n**And** retry with backoff\n**And** after MAX_RETRIES, atomically write event + update to FAILED + send to DLQ\n\n## Payment Token Service Client\n\n```python\nclass PaymentTokenServiceClient:\n    def __init__(self, base_url: str, service_auth_token: str):\n        self.base_url = base_url\n        self.auth_token = service_auth_token\n    \n    async def decrypt(\n        self,\n        payment_token: str,\n        restaurant_id: str,\n        requesting_service: str\n    ) -> PaymentData:\n        \"\"\"\n        Calls Payment Token Service /internal/decrypt endpoint.\n        \n        Returns:\n            PaymentData with decrypted card details\n        \n        Raises:\n            TokenNotFound: 404 - token doesn't exist\n            TokenExpired: 410 - token expired\n            Forbidden: 403 - restaurant mismatch or unauthorized\n            ServiceUnavailable: 5xx or timeout\n        \"\"\"\n        response = await self.http_client.post(\n            f\"{self.base_url}/internal/v1/decrypt\",\n            headers={\n                \"Content-Type\": \"application/x-protobuf\",\n                \"X-Service-Auth\": self.auth_token,\n                \"X-Request-ID\": generate_correlation_id()\n            },\n            data=DecryptTokenRequest(\n                payment_token=payment_token,\n                restaurant_id=restaurant_id,\n                requesting_service=requesting_service\n            ).SerializeToString(),\n            timeout=5.0\n        )\n        \n        if response.status == 404:\n            raise TokenNotFound(f\"Token {payment_token} not found\")\n        elif response.status == 410:\n            raise TokenExpired(f\"Token {payment_token} expired\")\n        elif response.status == 403:\n            raise Forbidden(f\"Unauthorized access to token {payment_token}\")\n        elif response.status >= 500 or response.timeout:\n            raise ServiceUnavailable(\"Payment Token Service unavailable\")\n        \n        return DecryptTokenResponse.FromString(response.body).payment_data\n```\n\n## Processor Integration Interfaces\n\n### Stripe Processor\n```python\nclass StripeProcessor:\n    async def authorize(\n        self,\n        payment_data: PaymentData,\n        amount_cents: int,\n        currency: str,\n        config: dict\n    ) -> AuthorizationResult:\n        \"\"\"\n        Calls Stripe API: POST /v1/charges\n        \n        Errors:\n        - StripeCardError (decline) → DENIED\n        - StripeAPIError (5xx) → Retry\n        - StripeTimeout → Retry\n        \"\"\"\n        import stripe\n        \n        stripe.api_key = config['api_key']\n        \n        try:\n            charge = stripe.Charge.create(\n                amount=amount_cents,\n                currency=currency.lower(),\n                source={\n                    \"object\": \"card\",\n                    \"number\": payment_data.card_number,\n                    \"exp_month\": payment_data.exp_month,\n                    \"exp_year\": payment_data.exp_year,\n                    \"cvc\": payment_data.cvv,\n                    \"name\": payment_data.cardholder_name\n                },\n                capture=False,  # Authorization only, capture later\n                statement_descriptor=config.get('statement_descriptor')\n            )\n            \n            return AuthorizationResult(\n                status=AuthStatus.AUTHORIZED,\n                processor_auth_id=charge.id,\n                processor_name=\"stripe\",\n                authorized_amount_cents=charge.amount,\n                currency=charge.currency.upper(),\n                authorization_code=charge.authorization_code,\n                authorized_at=charge.created,\n                processor_metadata={\n                    \"balance_transaction\": charge.balance_transaction,\n                    \"network\": charge.payment_method_details.card.network\n                }\n            )\n            \n        except stripe.error.CardError as e:\n            # Card declined\n            return AuthorizationResult(\n                status=AuthStatus.DENIED,\n                processor_name=\"stripe\",\n                denial_code=e.code,\n                denial_reason=e.user_message,\n                processor_metadata={\"decline_code\": e.decline_code}\n            )\n        \n        except (stripe.error.APIError, stripe.error.RateLimitError) as e:\n            # Retryable errors\n            raise ProcessorTimeout(f\"Stripe API error: {e}\")\n```\n\n### Chase Processor (Future)\n```python\nclass ChaseProcessor:\n    async def authorize(...) -> AuthorizationResult:\n        \"\"\"\n        Calls Chase payment gateway\n        \"\"\"\n```\n\n## Error Classification\n\n**Retryable Errors (Transient):**\n- Processor timeout\n- Processor 500/503 errors\n- Network errors\n- Payment Token Service unavailable (5xx, timeout)\n\n**Non-Retryable Errors (Terminal):**\n- Invalid payment token (404 from Payment Token Service)\n- Expired payment token (410 from Payment Token Service)\n- Invalid request format (400)\n- Authentication failure (401)\n- Processor hard decline (but record as DENIED, not FAILED)\n\n## Database Operations\n\n### Acquire Lock\n```sql\nINSERT INTO auth_processing_locks (auth_request_id, worker_id, expires_at)\nVALUES ($1, $2, NOW() + INTERVAL '30 seconds')\nON CONFLICT (auth_request_id) DO NOTHING\nRETURNING auth_request_id;\n\n-- If returns NULL → lock already held\n```\n\n### Release Lock\n```sql\nDELETE FROM auth_processing_locks\nWHERE auth_request_id = $1 AND worker_id = $2;\n```\n\n### Check for Void\n```sql\nSELECT EXISTS (\n    SELECT 1 FROM payment_events\n    WHERE aggregate_id = $1\n      AND event_type = 'AuthVoidRequested'\n) AS is_voided;\n```\n\n### Get Next Sequence Number\n```sql\nSELECT COALESCE(MAX(sequence_number), 0) + 1\nFROM payment_events\nWHERE aggregate_id = $1;\n```\n\n### Cleanup Expired Locks (Background Task)\n```sql\nDELETE FROM auth_processing_locks\nWHERE expires_at < NOW();\n```\n\n## Configuration\n\n```yaml\nworker:\n  sqs_queue_url: \"https://sqs.us-east-1.amazonaws.com/.../auth-requests.fifo\"\n  batch_size: 1\n  wait_time_seconds: 20  # Long polling\n  visibility_timeout: 30\n  max_retries: 5\n  lock_ttl_seconds: 30\n  \npayment_token_service:\n  base_url: \"https://payment-token-service.internal\"\n  service_auth_token: \"<from-secrets-manager>\"\n  timeout_seconds: 5\n  max_retries: 2\n  \nprocessors:\n  stripe:\n    api_key: \"sk_live_...\"\n    timeout_seconds: 10\n  chase:\n    merchant_id: \"...\"\n    timeout_seconds: 15\n```\n\n## Dependencies\n- **Payment Token Service**: Internal /internal/decrypt endpoint\n- **Payment Processors**: Stripe, Chase, Worldpay APIs\n- **PostgreSQL**: Event store and read models (shared with Authorization API)\n- **SQS**: Auth request queue\n\n## Deployment\n- **ECS Service**: Long-running workers (recommended for stable connections)\n- **OR Lambda**: Triggered by SQS (for auto-scaling, but cold starts)\n- **Scaling**: Auto-scale based on SQS queue depth\n- **Health Check**: Worker heartbeat to CloudWatch\n\n## Monitoring & Observability\n- **Metrics**: Auth processing latency, success/failure rates, retry counts, lock contention\n- **Logs**: Structured logging (JSON) with correlation IDs\n- **Alarms**: \n  - Dead letter queue depth > 10\n  - Processing latency > p99\n  - Payment Token Service error rate > 5%\n- **Tracing**: X-Ray for distributed tracing across services\n\n## Testing Strategy\n- **Unit tests**: Lock acquisition, error classification, retry logic, transaction logic\n- **Integration tests**: Full flow with mocked Payment Token Service + mocked processor + real database\n- **Contract tests**: Verify Payment Token Service client matches actual API\n- **Transaction tests**: Verify event + read model are atomic (simulate failures)\n- **Chaos tests**: Simulate worker crashes, processor timeouts, lock expiry, Payment Token Service outages\n- **Load tests**: Sustained 300 QPS with queue backlog","priority":0,"archived":0,"archived_at":null,"created_at":"2025-11-10 04:35:31","updated_at":"2025-11-10 06:42:17","parent_id":null,"parent_uuid":null,"relationships":[],"tags":["processor","service-spec","worker"]}
{"id":"s-4nmw","uuid":"4eaf2f58-1686-4093-b8d2-cae3dd56021f","title":"Detokenization Service","file_path":"specs/detokenization_service.md","content":"## DEPRECATED\n\nThis service has been merged into the **Payment Token Service** (s-7ujm).\n\nThe internal decryption endpoint `/internal/decrypt` is now part of the Payment Token Service, as both services share the same database and PCI compliance boundary.\n\nSee **Payment Token Service** spec for the combined service architecture.\n\n## Migration Notes\n- Auth Processor Workers now call Payment Token Service directly\n- Detokenization logic is part of Payment Token Service\n- Single database, single service for PCI zone\n- Internal `/internal/decrypt` endpoint documented in Payment Token Service spec\n","priority":0,"archived":1,"archived_at":"2025-11-10T06:47:51.946Z","created_at":"2025-11-10 04:35:32","updated_at":"2025-11-10 06:47:51","parent_id":null,"parent_uuid":null,"relationships":[],"tags":["internal","pci-compliant","service-spec"]}
{"id":"s-8c0t","uuid":"c9d1a884-9641-4933-ab43-1161a52be508","title":"Shared Infrastructure Components","file_path":"specs/shared_infrastructure_components.md","content":"## Overview\n\nShared infrastructure, database schemas, queue definitions, and cross-cutting concerns used by all services. Includes **Transactional Outbox Pattern** for reliable event-to-queue delivery.\n\n## Database: PostgreSQL (Aurora)\n\n### Instance Configuration\n\n- **Engine**: PostgreSQL 15+ (Aurora Serverless v2 recommended)\n- **Multi-AZ**: Enabled for high availability\n- **Backups**: Automated daily snapshots, 30-day retention\n- **Read Replicas**: 1-2 for read scaling (status queries)\n- **Connection Pooling**: PgBouncer or RDS Proxy\n\n### Database Separation\n\n**Payment Token Database** (PCI zone):\n\n- Isolated RDS instance\n- Only accessible by Payment Token Service\n- Encrypted at rest with AWS KMS LALALA\n- Separate VPC subnet with strict security groups\n\n**Payment Events Database** (main):\n\n- Shared by Authorization API and Auth Processor Workers\n- Contains: payment\\_events, auth\\_request\\_state, outbox, configs\n\n```sql\n-- payment_tokens_db (isolated)\nCREATE DATABASE payment_tokens_db;\n\n-- payment_events_db (main)\nCREATE DATABASE payment_events_db;\n```\n\n## Queue Architecture (AWS SQS)\n\n### Auth Request Queue (FIFO)\n\n```\nName: payment-auth-requests.fifo\nType: FIFO\nDeduplication: Message deduplication ID = auth_request_id\nMessage Group ID: restaurant_id\nVisibility Timeout: 30 seconds\nMessage Retention: 4 days\nMax Receive Count: 5\nDead Letter Queue: payment-auth-requests-dlq.fifo\n```\n\n**Message Format:**\n\n```json\n{\n  \"auth_request_id\": \"550e8400-e29b-41d4-a716-446655440000\",\n  \"restaurant_id\": \"f47ac10b-58cc-4372-a567-0e02b2c3d479\",\n  \"created_at\": 1234567890\n}\n```\n\n**Population Method**: Outbox processor (runs in Authorization API) polls `outbox` table and sends to SQS\n\n### Void Request Queue (Standard)\n\n```\nName: payment-void-requests\nType: Standard (order not critical)\nVisibility Timeout: 60 seconds\nMessage Retention: 14 days (retry for up to X hours)\nMax Receive Count: 20 (more retries for voids)\nDead Letter Queue: payment-void-requests-dlq\n```\n\n### Dead Letter Queues\n\n**Auth Requests DLQ:**\n\n```\nName: payment-auth-requests-dlq.fifo\nPurpose: Terminal auth failures (invalid token, max retries)\nAlarm: > 10 messages\nRetention: 14 days (manual review)\n```\n\n**Void Requests DLQ:**\n\n```\nName: payment-void-requests-dlq\nPurpose: Failed voids after all retries\nAlarm: > 5 messages\n```\n\n## Event Store Schema (Detailed)\n\n```sql\n-- Main event store (append-only, never update/delete)\nCREATE TABLE payment_events (\n    id BIGSERIAL PRIMARY KEY,\n    event_id UUID UNIQUE NOT NULL DEFAULT gen_random_uuid(),\n    aggregate_id UUID NOT NULL,  -- auth_request_id, void_request_id, etc.\n    aggregate_type VARCHAR(50) NOT NULL,  -- 'auth_request', 'void_request'\n    event_type VARCHAR(100) NOT NULL,\n    event_data BYTEA NOT NULL,  -- Protobuf serialized\n    metadata JSONB DEFAULT '{}'::jsonb,\n    created_at TIMESTAMP NOT NULL DEFAULT NOW(),\n    sequence_number INTEGER NOT NULL,\n\n    CONSTRAINT unique_aggregate_sequence UNIQUE(aggregate_id, sequence_number),\n    CONSTRAINT check_sequence_positive CHECK (sequence_number > 0)\n);\n\n-- Indexes for fast queries\nCREATE INDEX idx_aggregate_events ON payment_events(aggregate_id, sequence_number);\nCREATE INDEX idx_event_type_created ON payment_events(event_type, created_at DESC);\nCREATE INDEX idx_created_at ON payment_events(created_at DESC);\n\n-- Partitioning for archival (optional, for future)\n-- Partition by created_at monthly for easy archival\n```\n\n## Transactional Outbox Pattern\n\n### Outbox Table\n\n**Critical for reliable event → queue delivery with at-least-once guarantee.**\n\n```sql\n-- Outbox for reliable queue delivery (Transactional Outbox Pattern)\nCREATE TABLE outbox (\n    id BIGSERIAL PRIMARY KEY,\n    aggregate_id UUID NOT NULL,  -- auth_request_id or void_request_id\n    message_type VARCHAR(100) NOT NULL,  -- 'auth_request_queued', 'void_request_queued'\n    payload JSONB NOT NULL,  -- Message body for SQS\n    created_at TIMESTAMP NOT NULL DEFAULT NOW(),\n    processed_at TIMESTAMP,  -- NULL = unprocessed, NOT NULL = sent to SQS\n\n    INDEX idx_unprocessed (created_at) WHERE processed_at IS NULL  -- Partial index for efficiency!\n);\n```\n\n**How it works:**\n\n1. Authorization API writes event + read model + outbox entry in **single transaction**\n1. Outbox processor (background thread in Authorization API) polls `WHERE processed_at IS NULL`\n1. Sends messages to SQS\n1. Marks as processed: `UPDATE outbox SET processed_at = NOW()`\n\n**Guarantees:**\n\n- ✅ Atomic write (event + outbox)\n- ✅ At-least-once delivery to SQS\n- ✅ No message loss (survives crashes)\n- ✅ SQS FIFO deduplication handles duplicates\n\n### Outbox Cleanup (Optional)\n\nProcessed outbox entries can be archived/deleted after retention period:\n\n```sql\n-- Delete processed outbox entries older than 7 days\nDELETE FROM outbox\nWHERE processed_at < NOW() - INTERVAL '7 days';\n```\n\nRun daily as maintenance job.\n\n## Read Models (Materialized Views)\n\n### Auth Request State (Optimized for Queries)\n\n**Updated synchronously in same transaction as events (by Authorization API and Workers).**\n\n```sql\nCREATE TABLE auth_request_state (\n    auth_request_id UUID PRIMARY KEY,\n    restaurant_id UUID NOT NULL,\n    payment_token VARCHAR(64) NOT NULL,\n\n    -- Current state\n    status VARCHAR(20) NOT NULL,  -- PENDING, PROCESSING, AUTHORIZED, DENIED, etc.\n\n    -- Request details\n    amount_cents BIGINT NOT NULL,\n    currency VARCHAR(3) NOT NULL,\n\n    -- Result (populated when completed by worker)\n    processor_auth_id VARCHAR(255),\n    processor_name VARCHAR(50),\n    authorized_amount_cents BIGINT,\n    authorization_code VARCHAR(100),\n\n    -- Denial details (if DENIED)\n    denial_code VARCHAR(50),\n    denial_reason TEXT,\n\n    -- Timestamps\n    created_at TIMESTAMP NOT NULL,\n    updated_at TIMESTAMP NOT NULL DEFAULT NOW(),\n    completed_at TIMESTAMP,\n\n    -- Metadata\n    metadata JSONB DEFAULT '{}'::jsonb,\n\n    -- Event sourcing bookkeeping\n    last_event_sequence INTEGER NOT NULL DEFAULT 0,\n    last_event_id UUID,\n\n    -- Indexes\n    CONSTRAINT check_status CHECK (status IN ('PENDING', 'PROCESSING', 'AUTHORIZED', 'DENIED', 'FAILED', 'VOIDED', 'EXPIRED'))\n);\n\nCREATE INDEX idx_restaurant_created ON auth_request_state(restaurant_id, created_at DESC);\nCREATE INDEX idx_status ON auth_request_state(status) WHERE status IN ('PENDING', 'PROCESSING');\nCREATE INDEX idx_payment_token ON auth_request_state(payment_token);\nCREATE INDEX idx_completed_at ON auth_request_state(completed_at DESC) WHERE completed_at IS NOT NULL;\n\n-- Auto-update updated_at trigger\nCREATE OR REPLACE FUNCTION update_updated_at_column()\nRETURNS TRIGGER AS $$\nBEGIN\n   NEW.updated_at = NOW();\n   RETURN NEW;\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER update_auth_request_state_updated_at\n    BEFORE UPDATE ON auth_request_state\n    FOR EACH ROW\n    EXECUTE FUNCTION update_updated_at_column();\n```\n\n### Restaurant Payment Configs (Cache)\n\n```sql\nCREATE TABLE restaurant_payment_configs (\n    restaurant_id UUID PRIMARY KEY,\n    config_version VARCHAR(50) NOT NULL,\n\n    -- Processor selection\n    processor_name VARCHAR(50) NOT NULL,  -- \"stripe\", \"chase\", \"worldpay\"\n\n    -- Processor-specific config (JSON)\n    processor_config JSONB NOT NULL,\n    -- Example for Stripe:\n    -- {\n    --   \"stripe_api_key\": \"sk_test_...\",\n    --   \"statement_descriptor\": \"RESTAURANT NAME\"\n    -- }\n\n    -- Metadata\n    is_active BOOLEAN NOT NULL DEFAULT true,\n    updated_at TIMESTAMP NOT NULL DEFAULT NOW(),\n\n    CONSTRAINT check_processor CHECK (processor_name IN ('stripe', 'chase', 'worldpay'))\n);\n\nCREATE INDEX idx_active_configs ON restaurant_payment_configs(is_active) WHERE is_active = true;\n\n-- Initial seed data (for testing - single restaurant with Stripe)\nINSERT INTO restaurant_payment_configs (restaurant_id, config_version, processor_name, processor_config, updated_at)\nVALUES (\n    '00000000-0000-0000-0000-000000000001'::UUID,\n    'v1',\n    'stripe',\n    '{\"stripe_api_key\": \"sk_test_...\", \"statement_descriptor\": \"TEST RESTAURANT\"}'::JSONB,\n    NOW()\n);\n```\n\n### Idempotency Keys\n\n```sql\nCREATE TABLE auth_idempotency_keys (\n    idempotency_key VARCHAR(255) NOT NULL,\n    restaurant_id UUID NOT NULL,\n    auth_request_id UUID NOT NULL,\n    created_at TIMESTAMP NOT NULL DEFAULT NOW(),\n    expires_at TIMESTAMP NOT NULL DEFAULT NOW() + INTERVAL '24 hours',\n\n    PRIMARY KEY (idempotency_key, restaurant_id)\n);\n\nCREATE INDEX idx_idempotency_expires ON auth_idempotency_keys(expires_at);\n\n-- Cleanup expired keys (background job)\nCREATE INDEX idx_expired_keys ON auth_idempotency_keys(expires_at) WHERE expires_at < NOW();\n```\n\n### Processing Locks\n\n```sql\nCREATE TABLE auth_processing_locks (\n    auth_request_id UUID PRIMARY KEY,\n    worker_id VARCHAR(255) NOT NULL,\n    locked_at TIMESTAMP NOT NULL DEFAULT NOW(),\n    expires_at TIMESTAMP NOT NULL DEFAULT NOW() + INTERVAL '30 seconds',\n\n    CONSTRAINT check_expires_after_locked CHECK (expires_at > locked_at)\n);\n\nCREATE INDEX idx_lock_expires ON auth_processing_locks(expires_at);\n\n-- Cleanup expired locks (background job)\n-- Note: This is also done by workers, but good hygiene to have separate cleanup\n```\n\n## Protobuf Definitions (Shared)\n\nAll services share common protobuf definitions for consistency.\n\n**See Issue [[i-xxxx]]: Complete Protobuf Definitions** for full `.proto` files.\n\n```protobuf\nsyntax = \"proto3\";\n\npackage payments.v1;\n\n// Common types\nmessage Money {\n  int64 amount_cents = 1;\n  string currency = 2;  // ISO 4217\n}\n\nmessage Timestamp {\n  int64 seconds = 1;\n  int32 nanos = 2;\n}\n\n// Status enums\nenum AuthStatus {\n  AUTH_STATUS_UNSPECIFIED = 0;\n  AUTH_STATUS_PENDING = 1;\n  AUTH_STATUS_PROCESSING = 2;\n  AUTH_STATUS_AUTHORIZED = 3;\n  AUTH_STATUS_DENIED = 4;\n  AUTH_STATUS_FAILED = 5;\n  AUTH_STATUS_VOIDED = 6;\n  AUTH_STATUS_EXPIRED = 7;\n}\n\n// Event base\nmessage EventMetadata {\n  string event_id = 1;\n  string correlation_id = 2;\n  string causation_id = 3;\n  Timestamp created_at = 4;\n}\n\n// Error types\nmessage ErrorDetails {\n  string error_code = 1;\n  string error_message = 2;\n  bool is_retryable = 3;\n  int32 retry_count = 4;\n}\n```\n\n## Archival Strategy\n\n### Hot Data (0-30 days)\n\n- Stored in primary PostgreSQL database\n- Full query capabilities\n- Indexed for fast lookups\n\n### Warm Data (30-365 days)\n\n- Move to separate archive table or database\n- Partitioned by month\n- Less frequently accessed\n- Consider read replicas for queries\n\n### Cold Data (365+ days)\n\n- Export to S3 (Parquet format)\n- Queryable via AWS Athena\n- Compressed and encrypted\n- Retained for 7 years (PCI compliance)\n\n### Archival Process (Cron Job)\n\n```sql\n-- Monthly job: Archive events older than 30 days\nINSERT INTO payment_events_archive\nSELECT * FROM payment_events\nWHERE created_at < NOW() - INTERVAL '30 days';\n\nDELETE FROM payment_events\nWHERE created_at < NOW() - INTERVAL '30 days';\n\n-- Export to S3\nCOPY payment_events_archive TO 's3://payment-events/archive/2024-01.parquet'\nWITH (FORMAT PARQUET, COMPRESSION GZIP);\n```\n\n## Monitoring & Observability\n\n### Key Metrics\n\n- **Auth Request Latency**: p50, p95, p99 from POST /authorize to completion\n- **Queue Depth**: Number of pending messages in SQS\n- **Outbox Depth**: Number of unprocessed outbox entries (`COUNT(*) WHERE processed_at IS NULL`)\n- **Worker Processing Rate**: Messages processed per second\n- **Error Rates**: Failed auths, DLQ depth\n- **Lock Contention**: Failed lock acquisitions\n\n### CloudWatch Alarms\n\n- **DLQ depth > 10** → Page on-call\n- **Outbox unprocessed > 1000** → Warning (outbox processor may be down)\n- **Auth latency p99 > 10s** → Warning\n- **Worker processing rate drop > 50%** → Warning\n- **Database CPU > 80%** → Scale up\n\n### Structured Logging Format\n\n```json\n{\n  \"timestamp\": \"2024-01-15T10:30:00Z\",\n  \"level\": \"INFO\",\n  \"service\": \"auth-processor-worker\",\n  \"correlation_id\": \"550e8400-e29b-41d4-a716-446655440000\",\n  \"auth_request_id\": \"f47ac10b-58cc-4372-a567-0e02b2c3d479\",\n  \"event\": \"auth_attempt_started\",\n  \"duration_ms\": 150,\n  \"processor\": \"stripe\"\n}\n```\n\n## Security & Compliance\n\n### PCI DSS Requirements\n\n- Payment Token Service isolated (separate VPC, database)\n- All payment data encrypted at rest (AWS KMS)\n- All connections use TLS 1.3\n- Audit logs immutable and retained\n- No payment data in application logs\n\n### Network Architecture\n\n```\n┌─────────────────────────────────────────────────────┐\n│                  Public Subnet                      │\n│  - API Gateway / Load Balancer                      │\n└─────────────────────────────────────────────────────┘\n                      │\n┌─────────────────────────────────────────────────────┐\n│                 Private Subnet (App)                │\n│  - Authorization API (with outbox processor)        │\n│  - Auth Processor Workers                           │\n└─────────────────────────────────────────────────────┘\n                      │\n┌─────────────────────────────────────────────────────┐\n│             Private Subnet (PCI Zone)               │\n│  - Payment Token Service                            │\n│  - Payment Token Database (isolated RDS)            │\n└─────────────────────────────────────────────────────┘\n                      │\n┌─────────────────────────────────────────────────────┐\n│                 Private Subnet (Data)               │\n│  - Payment Events Database (RDS Aurora)             │\n│    - payment_events                                 │\n│    - auth_request_state                             │\n│    - outbox                                         │\n│  - ElastiCache (optional, for caching)              │\n└─────────────────────────────────────────────────────┘\n```\n\n## Testing Infrastructure\n\n### LocalStack (for local development)\n\n```yaml\n# docker-compose.yml\nservices:\n  localstack:\n    image: localstack/localstack\n    ports:\n      - \"4566:4566\"\n    environment:\n      - SERVICES=sqs,kms\n      - DEBUG=1\n\n  postgres:\n    image: postgres:15\n    ports:\n      - \"5432:5432\"\n    environment:\n      - POSTGRES_PASSWORD=password\n      - POSTGRES_DB=payment_events_db\n    volumes:\n      - ./init.sql:/docker-entrypoint-initdb.d/init.sql\n```\n\n### init.sql (Database Bootstrap)\n\n```sql\n-- Run all CREATE TABLE statements from above\n-- Includes: payment_events, outbox, auth_request_state, etc.\n```\n\n### Test Data Fixtures\n\n- Factory pattern for creating test events\n- Seed data for restaurant configs\n- Mock payment processor responses\n\n## Configuration Management\n\nAll configuration stored in AWS SSM Parameter Store or Secrets Manager:\n\n```\n/payments/production/database/url\n/payments/production/sqs/auth-requests-queue-url\n/payments/production/stripe/api-key (SecretString)\n/payments/production/token-service/internal-api-url\n```\n\n## Background Jobs\n\n### Outbox Processor (in Authorization API)\n\n- **Frequency**: Every 100ms\n- **Query**: `SELECT * FROM outbox WHERE processed_at IS NULL ORDER BY created_at LIMIT 100 FOR UPDATE SKIP LOCKED`\n- **Action**: Send to SQS, mark as processed\n\n### Expired Idempotency Keys Cleanup\n\n- **Frequency**: Hourly\n- **Query**: `DELETE FROM auth_idempotency_keys WHERE expires_at < NOW()`\n\n### Expired Locks Cleanup\n\n- **Frequency**: Every minute\n- **Query**: `DELETE FROM auth_processing_locks WHERE expires_at < NOW()`\n\n### Outbox Cleanup (Optional)\n\n- **Frequency**: Daily\n- **Query**: `DELETE FROM outbox WHERE processed_at < NOW() - INTERVAL '7 days'`","priority":0,"archived":0,"archived_at":null,"created_at":"2025-11-10 04:35:33","updated_at":"2025-11-10 18:14:47","parent_id":null,"parent_uuid":null,"relationships":[],"tags":["database","infrastructure","shared"]}
{"id":"s-94si","uuid":"a5b75599-960a-478a-9832-126b098c2faf","title":"Event Sourcing & Read Model Architecture","file_path":"specs/event_sourcing_read_model_architecture.md","content":"## Overview\nComprehensive guide to the event sourcing and read model architecture used across the payments infrastructure. This document clarifies **transaction boundaries**, **read model update patterns**, and **outbox-based queue integration**.\n\n## Core Principles\n\n1. **Events are immutable source of truth** - stored in `payment_events` table, never updated or deleted\n2. **Read models are derived projections** - updated synchronously in same transaction as events\n3. **Outbox pattern ensures reliable queue delivery** - atomic writes, at-least-once delivery\n4. **Strong consistency for reads** - no eventual consistency delay for status queries\n\n## Transaction Boundaries\n\n### Authorization API: POST /authorize\n\n```\n┌─────────────────────────────────────────────────────────────┐\n│                     BEGIN TRANSACTION                        │\n│                                                              │\n│  1. Check idempotency (SELECT)                               │\n│  2. Write event: AuthRequestCreated                          │\n│     INSERT INTO payment_events (...)                         │\n│                                                              │\n│  3. Write read model                                         │\n│     INSERT INTO auth_request_state (status='PENDING', ...)   │\n│                                                              │\n│  4. Write outbox entry                                       │\n│     INSERT INTO outbox (message_type='auth_request_queued')  │\n│                                                              │\n│  5. Write idempotency key                                    │\n│     INSERT INTO auth_idempotency_keys (...)                  │\n│                                                              │\n│                      COMMIT                                  │\n└─────────────────────────────────────────────────────────────┘\n\nResult: Event + Read Model + Outbox + Idempotency written atomically\nIf any step fails → entire transaction rolls back\n```\n\n### Auth Processor Worker: Process Request\n\n```\n┌─────────────────────────────────────────────────────────────┐\n│  1. Dequeue from SQS (visibility timeout starts)             │\n│  2. Acquire lock (INSERT INTO auth_processing_locks)         │\n│  3. Check for void event (SELECT)                            │\n│  4. Fetch config (SELECT)                                    │\n│  5. Call Payment Token Service (external API)                │\n│  6. Call Payment Processor (external API - Stripe)           │\n│                                                              │\n│                     BEGIN TRANSACTION                        │\n│                                                              │\n│  7. Write event: AuthResponseReceived                        │\n│     INSERT INTO payment_events (...)                         │\n│                                                              │\n│  8. Update read model                                        │\n│     UPDATE auth_request_state                                │\n│     SET status='AUTHORIZED', processor_auth_id=..., ...      │\n│                                                              │\n│                      COMMIT                                  │\n│                                                              │\n│  9. Delete SQS message (ACK)                                 │\n│  10. Release lock (DELETE FROM auth_processing_locks)        │\n└─────────────────────────────────────────────────────────────┘\n\nResult: Event + Read Model updated atomically\nExternal API calls happen BEFORE transaction (if they fail, retry via SQS)\n```\n\n## Read Model Update Patterns\n\n### Pattern: Synchronous Updates (RECOMMENDED)\n\n**Both Authorization API and Workers update read models in same transaction as events.**\n\n**Advantages:**\n- ✅ Strong consistency - read models always reflect latest events\n- ✅ No delay for status queries\n- ✅ Simpler architecture - no separate projection service\n- ✅ Transactional guarantees\n\n**Trade-offs:**\n- ⚠️ Read model logic distributed across services (API writes PENDING, worker writes AUTHORIZED)\n- ⚠️ Cannot rebuild read models from events alone (need application logic)\n\n**When to use:** When you need immediate consistency for user-facing queries (like payment status).\n\n### Alternative Pattern: Event-Driven Projections (NOT USED)\n\nA separate projection service listens to events and updates read models asynchronously.\n\n**NOT recommended for this system** because:\n- ❌ Eventual consistency not acceptable for payment status (users expect immediate updates)\n- ❌ Adds complexity (another service to maintain)\n- ❌ 100-500ms delay unacceptable for POST /authorize 5-second polling\n\n**When to use:** Analytics, reporting, or non-critical read models where eventual consistency is acceptable.\n\n## Outbox Pattern Details\n\n### Purpose\n\nEnsure **atomic** write of events + queue messages without distributed transactions.\n\n### How It Works\n\n```\nAuthorization API Transaction:\n  1. Write event to payment_events\n  2. Write read model to auth_request_state\n  3. Write outbox entry to outbox table\n  ───────────────────────────────────────\n  COMMIT (all succeed or all fail)\n\nBackground Outbox Processor (every 100ms):\n  1. SELECT * FROM outbox WHERE processed_at IS NULL FOR UPDATE SKIP LOCKED\n  2. Send each message to SQS\n  3. UPDATE outbox SET processed_at = NOW()\n```\n\n### Guarantees\n\n| Scenario | Outcome |\n|----------|---------|\n| Transaction commits | Outbox entry exists, will be sent to SQS |\n| Transaction rolls back | No outbox entry, no SQS message |\n| Outbox processor crashes | Unprocessed messages remain in DB, retried on restart |\n| SQS send fails | Outbox entry remains unprocessed, retried on next poll |\n| Duplicate SQS sends | SQS FIFO deduplication prevents duplicate processing |\n\n### Failure Modes\n\n**Q: What if outbox processor is down for extended period?**  \nA: Outbox entries queue up in database. Alarms trigger at > 1000 unprocessed. Messages sent when processor restarts.\n\n**Q: What if database fails after SQS send but before marking as processed?**  \nA: Message sent twice. SQS FIFO deduplication (MessageDeduplicationId=auth_request_id) prevents duplicate processing by worker.\n\n**Q: What if outbox table fills up?**  \nA: Run daily cleanup job: `DELETE FROM outbox WHERE processed_at < NOW() - INTERVAL '7 days'`. Monitor disk usage.\n\n## Event Replay & Debugging\n\n### Replaying Events\n\nEvents are immutable, so you can replay them to rebuild state:\n\n```sql\n-- Rebuild auth_request_state for a specific request\nDELETE FROM auth_request_state WHERE auth_request_id = $1;\n\nSELECT aggregate_id, event_type, event_data, sequence_number\nFROM payment_events\nWHERE aggregate_id = $1\nORDER BY sequence_number;\n\n-- Apply each event in order to reconstruct state\n```\n\n### Debugging Payment Flow\n\n```sql\n-- See full history of an auth request\nSELECT \n    event_type,\n    event_data,\n    created_at,\n    sequence_number\nFROM payment_events\nWHERE aggregate_id = '550e8400-e29b-41d4-a716-446655440000'\nORDER BY sequence_number;\n\n-- Check current state\nSELECT * FROM auth_request_state\nWHERE auth_request_id = '550e8400-e29b-41d4-a716-446655440000';\n\n-- Check if queued\nSELECT * FROM outbox\nWHERE aggregate_id = '550e8400-e29b-41d4-a716-446655440000';\n```\n\n## Consistency Checks\n\n### Event vs Read Model Consistency\n\nVerify read model is up-to-date:\n\n```sql\n-- Check if read model is behind\nSELECT \n    ars.auth_request_id,\n    ars.status,\n    ars.last_event_sequence,\n    (SELECT MAX(sequence_number) FROM payment_events WHERE aggregate_id = ars.auth_request_id) AS latest_event_sequence\nFROM auth_request_state ars\nWHERE ars.last_event_sequence < (SELECT MAX(sequence_number) FROM payment_events WHERE aggregate_id = ars.auth_request_id);\n```\n\nIf rows returned → read model is stale (should never happen if transactions are used correctly).\n\n### Outbox Lag\n\nMonitor unprocessed outbox entries:\n\n```sql\n-- Check outbox depth\nSELECT COUNT(*) AS unprocessed_count\nFROM outbox\nWHERE processed_at IS NULL;\n\n-- Check oldest unprocessed message\nSELECT MIN(created_at) AS oldest_unprocessed\nFROM outbox\nWHERE processed_at IS NULL;\n```\n\nAlert if `unprocessed_count > 1000` or `oldest_unprocessed > 5 minutes`.\n\n## Idempotency\n\n### Request-Level Idempotency\n\nClient provides `X-Idempotency-Key` header:\n\n```\nPOST /authorize\nX-Idempotency-Key: 8f7d6c5b-4a3e-2d1c-0b9a-8e7f6d5c4b3a\n\n→ Same idempotency key within 24 hours returns same auth_request_id\n```\n\n**Implementation:**\n```sql\n-- Check idempotency\nSELECT auth_request_id FROM auth_idempotency_keys\nWHERE idempotency_key = $1 AND restaurant_id = $2;\n\n-- If exists, return existing auth_request\n-- If not exists, create new auth request + write idempotency key\n```\n\n### Event-Level Idempotency\n\nEach event has unique `event_id` (UUID):\n\n```sql\nINSERT INTO payment_events (event_id, aggregate_id, event_type, ...)\nVALUES ($1, $2, $3, ...)\nON CONFLICT (event_id) DO NOTHING;\n```\n\nPrevents duplicate events if retry occurs.\n\n### Outbox-Level Idempotency\n\nSQS FIFO deduplication:\n\n```python\nsqs.send_message(\n    QueueUrl=\"auth-requests.fifo\",\n    MessageBody=payload,\n    MessageDeduplicationId=auth_request_id,  # Deduplication key\n    MessageGroupId=restaurant_id\n)\n```\n\nIf same `auth_request_id` sent twice within 5 minutes → SQS ignores duplicate.\n\n## Sequence Diagrams\n\n### Happy Path: POST /authorize → Worker → Response\n\n```\nClient          Auth API         Outbox Proc    SQS Queue      Worker          Processor\n  │                │                 │              │             │                │\n  ├─POST /auth────>│                 │              │             │                │\n  │                ├─BEGIN TX────────┤              │             │                │\n  │                ├─Write Event─────┤              │             │                │\n  │                ├─Write Read Model│              │             │                │\n  │                ├─Write Outbox────┤              │             │                │\n  │                ├─COMMIT──────────┤              │             │                │\n  │                │                 │              │             │                │\n  │<─202 Accepted──┤ (returns immediately)          │             │                │\n  │                │                 │              │             │                │\n  │                │   (100ms later) │              │             │                │\n  │                │                 ├─Poll Outbox─>│             │                │\n  │                │                 ├─Send to SQS──>│            │                │\n  │                │                 ├─Mark Processed              │                │\n  │                │                 │              │             │                │\n  │                │                 │              ├─Dequeue────>│                │\n  │                │                 │              │             ├─Decrypt Token─>│\n  │                │                 │              │             ├─Authorize─────>│\n  │                │                 │              │             │<─Response──────┤\n  │                │                 │              │             │                │\n  │                │                 │              │             ├─BEGIN TX───────┤\n  │                │                 │              │             ├─Write Event────┤\n  │                │                 │              │             ├─Update Read Mdl┤\n  │                │                 │              │             ├─COMMIT─────────┤\n  │                │                 │              │             ├─Delete Msg─────┤\n  │                │                 │              │             │                │\n  ├─GET /status───>│                 │              │             │                │\n  │<─200 AUTHORIZED┤ (reads from read model)        │             │                │\n```\n\n### Error Path: Invalid Token\n\n```\nClient          Auth API         Outbox Proc    SQS Queue      Worker          Token Svc\n  │                │                 │              │             │                │\n  ├─POST /auth────>│                 │              │             │                │\n  │                ├─[Transaction: write event + read model + outbox]             │\n  │<─202 Accepted──┤                 │              │             │                │\n  │                │                 ├─[Outbox sends to SQS]─────>│                │\n  │                │                 │              ├─Dequeue────>│                │\n  │                │                 │              │             ├─Decrypt Token─>│\n  │                │                 │              │             │<─404 Not Found─┤\n  │                │                 │              │             │                │\n  │                │                 │              │             ├─BEGIN TX───────┤\n  │                │                 │              │             ├─Write Event────┤\n  │                │                 │              │             │  (AuthAttempt  │\n  │                │                 │              │             │   Failed)      │\n  │                │                 │              │             ├─Update Read Mdl┤\n  │                │                 │              │             │  (status=FAILED│\n  │                │                 │              │             ├─COMMIT─────────┤\n  │                │                 │              │             ├─Send to DLQ────┤\n  │                │                 │              │             ├─Delete Msg─────┤\n  │                │                 │              │             │                │\n  ├─GET /status───>│                 │              │             │                │\n  │<─200 FAILED────┤ (reads from read model)        │             │                │\n```\n\n## Best Practices\n\n### DO:\n- ✅ Always write events + read models in same transaction\n- ✅ Use outbox pattern for queue messages\n- ✅ Include sequence numbers on events for ordering\n- ✅ Store protobuf-serialized events for forward/backward compatibility\n- ✅ Monitor outbox depth and event lag\n\n### DON'T:\n- ❌ Never update or delete events\n- ❌ Don't send to SQS directly from application code (use outbox)\n- ❌ Don't update read models outside of transactions\n- ❌ Don't skip sequence numbers (use `MAX(sequence_number) + 1`)\n- ❌ Don't store sensitive data in event metadata\n\n## Testing Strategy\n\n### Unit Tests\n- Event serialization/deserialization\n- Read model projection logic\n- Idempotency key checks\n\n### Integration Tests\n- Full transaction flows (event + read model + outbox)\n- Outbox processor sends to LocalStack SQS\n- Worker processes and updates read model\n\n### Chaos Tests\n- Kill outbox processor mid-processing → verify messages retried\n- Simulate transaction failures → verify rollback\n- Send duplicate SQS messages → verify deduplication\n\n### Consistency Tests\n- Verify read model matches event history\n- Verify outbox eventually empties (no stuck messages)\n- Verify no lost messages (every event has outbox entry)\n\n## References\n\n- **Transactional Outbox Pattern**: https://microservices.io/patterns/data/transactional-outbox.html\n- **Event Sourcing**: https://martinfowler.com/eaaDev/EventSourcing.html\n- **CQRS**: https://martinfowler.com/bliki/CQRS.html","priority":0,"archived":0,"archived_at":null,"created_at":"2025-11-10 06:45:11","updated_at":"2025-11-10 06:45:11","parent_id":null,"parent_uuid":null,"relationships":[],"tags":["architecture","event-sourcing","patterns"]}

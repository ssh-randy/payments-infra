syntax = "proto3";

package payments.v1;

import "payments/v1/common.proto";

// Payment Token Service API messages
// Handles tokenization of payment data from POS devices

// Encryption metadata for API partner key flow
// Used when payment data is encrypted with API partner keys (online ordering)
// instead of BDK-based device encryption (POS terminals)
message EncryptionMetadata {
  // Key ID used for encryption (e.g., "primary", "demo-primary-key-001", "ak_{uuid}")
  string key_id = 1;

  // Encryption algorithm (e.g., "AES-256-GCM")
  string algorithm = 2;

  // Base64-encoded initialization vector (IV/nonce)
  string iv = 3;
}

// Request to create a payment token from encrypted payment data
message CreatePaymentTokenRequest {
  // UUID of the restaurant/merchant
  string restaurant_id = 1;

  // Payment data encrypted by POS device with derived key (BDK flow)
  // OR encrypted with API partner key (online ordering flow)
  bytes encrypted_payment_data = 2;

  // Device identifier for key derivation (BDK flow only)
  // Optional: only required when using BDK-based encryption
  optional string device_token = 3;

  // Client-provided idempotency key
  string idempotency_key = 4;

  // Optional metadata (e.g., card brand, last4 digits)
  map<string, string> metadata = 5;

  // Encryption metadata (API partner key flow only)
  // Optional: only provided when using API partner keys
  // If not provided, system assumes BDK-based device encryption
  optional EncryptionMetadata encryption_metadata = 6;
}

// Response after creating a payment token
message CreatePaymentTokenResponse {
  // Generated token in format: pt_<uuid>
  string payment_token = 1;

  // Restaurant ID that owns this token
  string restaurant_id = 2;

  // Unix timestamp when token expires
  int64 expires_at = 3;

  // Echoed metadata from request
  map<string, string> metadata = 4;
}

// Request to retrieve payment token metadata (not the actual payment data)
message GetPaymentTokenRequest {
  // Payment token to retrieve
  string payment_token = 1;

  // Must match token owner for authorization
  string restaurant_id = 2;
}

// Response with payment token metadata
message GetPaymentTokenResponse {
  // Payment token
  string payment_token = 1;

  // Restaurant ID that owns this token
  string restaurant_id = 2;

  // Unix timestamp when token was created
  int64 created_at = 3;

  // Unix timestamp when token expires
  int64 expires_at = 4;

  // Whether the token has expired
  bool is_expired = 5;

  // Token metadata (e.g., card brand, last4)
  map<string, string> metadata = 6;
}

// Request to decrypt a payment token (internal API, worker access only)
message DecryptPaymentTokenRequest {
  // Payment token to decrypt
  string payment_token = 1;

  // Restaurant ID for authorization check
  string restaurant_id = 2;

  // Name of the requesting service (e.g., "auth-processor-worker", "void-processor-worker")
  string requesting_service = 3;
}

// Response with decrypted payment data (internal API only)
message DecryptPaymentTokenResponse {
  // Decrypted payment data
  PaymentData payment_data = 1;

  // Token metadata (e.g., card_brand, last4)
  map<string, string> metadata = 2;
}

// Decrypted payment card data (highly sensitive - PCI scope)
message PaymentData {
  // Full card number (PAN)
  string card_number = 1;

  // Expiration month (MM format, e.g., "01" for January)
  string exp_month = 2;

  // Expiration year (YYYY format, e.g., "2025")
  string exp_year = 3;

  // Card verification value (CVV/CVC)
  string cvv = 4;

  // Cardholder name as it appears on the card
  string cardholder_name = 5;

  // Billing address (optional)
  Address billing_address = 6;
}
